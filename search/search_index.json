{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"whiteboxgui \u00b6 An interactive GUI for WhiteboxTools in a Jupyter-based environment GitHub repo: https://github.com/giswqs/whiteboxgui Documentation: https://giswqs.github.io/whiteboxgui PyPI: https://pypi.org/project/whiteboxgui conda-forge: https://anaconda.org/conda-forge/whiteboxgui WhiteboxTools: https://github.com/jblindsay/whitebox-tools User Manual: https://jblindsay.github.io/wbt_book whitebox-python: https://github.com/giswqs/whitebox-python whiteboxR: https://github.com/giswqs/whiteboxR whitebox-ArcGIS: https://github.com/giswqs/WhiteboxTools-ArcGIS Free software: MIT license Description \u00b6 The whiteboxgui Python package is a Jupyter frontend for WhiteboxTools, an advanced geospatial data analysis platform developed by Prof. John Lindsay ( webpage ; jblindsay ) at the University of Guelph's Geomorphometry and Hydrogeomatics Research Group . WhiteboxTools can be used to perform common geographical information systems (GIS) analysis operations, such as cost-distance analysis, distance buffering, and raster reclassification. Remote sensing and image processing tasks include image enhancement (e.g. panchromatic sharpening, contrast adjustments), image mosaicing, numerous filtering operations, simple classification (k-means), and common image transformations. WhiteboxTools also contains advanced tooling for spatial hydrological analysis (e.g. flow-accumulation, watershed delineation, stream network analysis, sink removal), terrain analysis (e.g. common terrain indices such as slope, curvatures, wetness index, hillshading; hypsometric analysis; multi-scale topographic position analysis), and LiDAR data processing. LiDAR point clouds can be interrogated (LidarInfo, LidarHistogram), segmented, tiled and joined, analyized for outliers, interpolated to rasters (DEMs, intensity images), and ground-points can be classified or filtered. WhiteboxTools is not a cartographic or spatial data visualization package; instead it is meant to serve as an analytical backend for other data visualization software, mainly GIS. The WhiteboxTools currently contains 447 tools, which are each grouped based on their main function into one of the following categories: Data Tools, GIS Analysis, Hydrological Analysis, Image Analysis, LiDAR Analysis, Mathematical and Statistical Analysis, Stream Network Analysis, and Terrain Analysis. For a listing of available tools, complete with documentation and usage details, please see the WhiteboxTools User Manual . Installation \u00b6 The whiteboxgui Python package can be installed using the following command: pip install whiteboxgui Usage \u00b6 The whiteboxgui provides a Graphical User Interface (GUI) for WhiteboxTools in a Jupyter-based environment, which can be invoked using the following Python script: import whiteboxgui whiteboxgui.show(verbose=True) Demo \u00b6 Credits \u00b6 This package was created with Cookiecutter and the giswqs/pypackage project template.","title":"Home"},{"location":"#whiteboxgui","text":"An interactive GUI for WhiteboxTools in a Jupyter-based environment GitHub repo: https://github.com/giswqs/whiteboxgui Documentation: https://giswqs.github.io/whiteboxgui PyPI: https://pypi.org/project/whiteboxgui conda-forge: https://anaconda.org/conda-forge/whiteboxgui WhiteboxTools: https://github.com/jblindsay/whitebox-tools User Manual: https://jblindsay.github.io/wbt_book whitebox-python: https://github.com/giswqs/whitebox-python whiteboxR: https://github.com/giswqs/whiteboxR whitebox-ArcGIS: https://github.com/giswqs/WhiteboxTools-ArcGIS Free software: MIT license","title":"whiteboxgui"},{"location":"#description","text":"The whiteboxgui Python package is a Jupyter frontend for WhiteboxTools, an advanced geospatial data analysis platform developed by Prof. John Lindsay ( webpage ; jblindsay ) at the University of Guelph's Geomorphometry and Hydrogeomatics Research Group . WhiteboxTools can be used to perform common geographical information systems (GIS) analysis operations, such as cost-distance analysis, distance buffering, and raster reclassification. Remote sensing and image processing tasks include image enhancement (e.g. panchromatic sharpening, contrast adjustments), image mosaicing, numerous filtering operations, simple classification (k-means), and common image transformations. WhiteboxTools also contains advanced tooling for spatial hydrological analysis (e.g. flow-accumulation, watershed delineation, stream network analysis, sink removal), terrain analysis (e.g. common terrain indices such as slope, curvatures, wetness index, hillshading; hypsometric analysis; multi-scale topographic position analysis), and LiDAR data processing. LiDAR point clouds can be interrogated (LidarInfo, LidarHistogram), segmented, tiled and joined, analyized for outliers, interpolated to rasters (DEMs, intensity images), and ground-points can be classified or filtered. WhiteboxTools is not a cartographic or spatial data visualization package; instead it is meant to serve as an analytical backend for other data visualization software, mainly GIS. The WhiteboxTools currently contains 447 tools, which are each grouped based on their main function into one of the following categories: Data Tools, GIS Analysis, Hydrological Analysis, Image Analysis, LiDAR Analysis, Mathematical and Statistical Analysis, Stream Network Analysis, and Terrain Analysis. For a listing of available tools, complete with documentation and usage details, please see the WhiteboxTools User Manual .","title":"Description"},{"location":"#installation","text":"The whiteboxgui Python package can be installed using the following command: pip install whiteboxgui","title":"Installation"},{"location":"#usage","text":"The whiteboxgui provides a Graphical User Interface (GUI) for WhiteboxTools in a Jupyter-based environment, which can be invoked using the following Python script: import whiteboxgui whiteboxgui.show(verbose=True)","title":"Usage"},{"location":"#demo","text":"","title":"Demo"},{"location":"#credits","text":"This package was created with Cookiecutter and the giswqs/pypackage project template.","title":"Credits"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/giswqs/whiteboxgui/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with bug and help wanted is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with enhancement and help wanted is open to whoever wants to implement it. Write Documentation \u00b6 whiteboxgui could always use more documentation, whether as part of the official whiteboxgui docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/giswqs/whiteboxgui/issues If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up whiteboxgui for local development. Fork the whiteboxgui repo on GitHub. Clone your fork locally: shell $ git clone git@github.com:your_name_here/whiteboxgui.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development: shell $ mkvirtualenv whiteboxgui $ cd whiteboxgui/ $ python setup.py develop Create a branch for local development: shell $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox: shell $ flake8 whiteboxgui tests $ python setup.py test or pytest $ tox To get flake8 and tox, just pip install them into your virtualenv. Commit your changes and push your branch to GitHub: shell $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and for PyPy. Check https://github.com/giswqs/whiteboxgui/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/giswqs/whiteboxgui/issues . If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with bug and help wanted is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with enhancement and help wanted is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"whiteboxgui could always use more documentation, whether as part of the official whiteboxgui docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/giswqs/whiteboxgui/issues If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up whiteboxgui for local development. Fork the whiteboxgui repo on GitHub. Clone your fork locally: shell $ git clone git@github.com:your_name_here/whiteboxgui.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development: shell $ mkvirtualenv whiteboxgui $ cd whiteboxgui/ $ python setup.py develop Create a branch for local development: shell $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox: shell $ flake8 whiteboxgui tests $ python setup.py test or pytest $ tox To get flake8 and tox, just pip install them into your virtualenv. Commit your changes and push your branch to GitHub: shell $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and for PyPy. Check https://github.com/giswqs/whiteboxgui/pull_requests and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"faq/","text":"FAQ \u00b6","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install whiteboxgui, run this command in your terminal: pip install whiteboxgui This is the preferred method to install whiteboxgui, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From sources \u00b6 The sources for whiteboxgui can be downloaded from the Github repo. You can clone the public repository: git clone git://github.com/giswqs/whiteboxgui","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install whiteboxgui, run this command in your terminal: pip install whiteboxgui This is the preferred method to install whiteboxgui, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-sources","text":"The sources for whiteboxgui can be downloaded from the Github repo. You can clone the public repository: git clone git://github.com/giswqs/whiteboxgui","title":"From sources"},{"location":"usage/","text":"Usage \u00b6 To use whiteboxgui in a project: import whiteboxgui whiteboxgui.show(verbose=True)","title":"Usage"},{"location":"usage/#usage","text":"To use whiteboxgui in a project: import whiteboxgui whiteboxgui.show(verbose=True)","title":"Usage"},{"location":"whiteboxgui/","text":"whiteboxgui module \u00b6 \u00b6 Main module. build_toolbox ( tools_dict , max_width = '1080px' , max_height = '600px' ) \u00b6 Build the toolbox for WhiteboxTools. Parameters: Name Type Description Default tools_dict dict A dictionary containing information for all tools. required max_width str The maximum width of the widget. '1080px' max_height str The maximum height of the widget. '600px' Returns: Type Description object An ipywidget representing the toolbox. Source code in whiteboxgui/whiteboxgui.py def build_toolbox ( tools_dict , max_width = \"1080px\" , max_height = \"600px\" ): \"\"\"Build the toolbox for WhiteboxTools. Args: tools_dict (dict): A dictionary containing information for all tools. max_width (str, optional): The maximum width of the widget. max_height (str, optional): The maximum height of the widget. Returns: object: An ipywidget representing the toolbox. \"\"\" left_widget = widgets . VBox ( layout = widgets . Layout ( min_width = \"175px\" )) center_widget = widgets . VBox ( layout = widgets . Layout ( min_width = \"200px\" , max_width = \"200px\" ) ) right_widget = widgets . Output ( layout = widgets . Layout ( width = \"630px\" , max_height = max_height ) ) full_widget = widgets . HBox ( [ left_widget , center_widget , right_widget ], layout = widgets . Layout ( max_width = max_width , max_height = max_height ), ) search_widget = widgets . Text ( placeholder = \"Search tools ...\" , layout = widgets . Layout ( width = \"170px\" ) ) label_widget = widgets . Label ( layout = widgets . Layout ( width = \"170px\" )) label_widget . value = f \" { len ( tools_dict ) } Available Tools\" close_btn = widgets . Button ( description = \"Close Toolbox\" , icon = \"close\" , layout = widgets . Layout ( width = \"170px\" ) ) categories = {} categories [ \"All Tools\" ] = [] for key in tools_dict . keys (): category = tools_dict [ key ][ \"category\" ] if category not in categories . keys (): categories [ category ] = [] categories [ category ] . append ( tools_dict [ key ][ \"name\" ]) categories [ \"All Tools\" ] . append ( tools_dict [ key ][ \"name\" ]) options = list ( categories . keys ()) all_tools = categories [ \"All Tools\" ] all_tools . sort () category_widget = widgets . Select ( options = options , layout = widgets . Layout ( width = \"170px\" , height = \"165px\" ) ) tools_widget = widgets . Select ( options = [], layout = widgets . Layout ( width = \"195px\" , height = \"400px\" ) ) def category_selected ( change ): if change [ \"new\" ]: selected = change [ \"owner\" ] . value options = categories [ selected ] options . sort () tools_widget . options = options label_widget . value = f \" { len ( options ) } Available Tools\" category_widget . observe ( category_selected , \"value\" ) def tool_selected ( change ): if change [ \"new\" ]: selected = change [ \"owner\" ] . value tool_dict = tools_dict [ selected ] with right_widget : right_widget . clear_output () display ( tool_gui ( tool_dict , max_height = max_height )) tools_widget . observe ( tool_selected , \"value\" ) def search_changed ( change ): if change [ \"new\" ]: keyword = change [ \"owner\" ] . value if len ( keyword ) > 0 : selected_tools = [] for tool in all_tools : if keyword . lower () in tool . lower (): selected_tools . append ( tool ) if len ( selected_tools ) > 0 : tools_widget . options = selected_tools label_widget . value = f \" { len ( selected_tools ) } Available Tools\" else : tools_widget . options = all_tools label_widget . value = f \" { len ( tools_dict ) } Available Tools\" search_widget . observe ( search_changed , \"value\" ) def close_btn_clicked ( b ): full_widget . close () close_btn . on_click ( close_btn_clicked ) category_widget . value = list ( categories . keys ())[ 0 ] tools_widget . options = all_tools left_widget . children = [ category_widget , search_widget , label_widget , close_btn ] center_widget . children = [ tools_widget ] return full_widget build_toolbox_tree ( tools_dict , folder_icon = 'folder' , tool_icon = 'wrench' ) \u00b6 Build the toolbox for WhiteboxTools. Parameters: Name Type Description Default tools_dict dict A dictionary containing information for all tools. required folder_icon str The font-awesome icon for tool categories. Defaults to \"folder\". 'folder' tool_icon str The font-awesome icon for tools. Defaults to \"wrench\". 'wrench' Returns: Type Description object An ipywidget representing the toolbox. Source code in whiteboxgui/whiteboxgui.py def build_toolbox_tree ( tools_dict , folder_icon = \"folder\" , tool_icon = \"wrench\" ): \"\"\"Build the toolbox for WhiteboxTools. Args: tools_dict (dict): A dictionary containing information for all tools. folder_icon (str, optional): The font-awesome icon for tool categories. Defaults to \"folder\". tool_icon (str, optional): The font-awesome icon for tools. Defaults to \"wrench\". Returns: object: An ipywidget representing the toolbox. \"\"\" left_widget = widgets . VBox () right_widget = widgets . VBox () full_widget = widgets . HBox ([ left_widget , right_widget ]) search_description = f \" { len ( tools_dict ) } tools available. Search tools ...\" search_box = widgets . Text ( placeholder = search_description ) search_box . layout . width = \"270px\" close_btn = widgets . Button ( icon = \"close\" , layout = widgets . Layout ( width = \"32px\" )) def close_btn_clicked ( b ): full_widget . close () close_btn . on_click ( close_btn_clicked ) tree_widget = widgets . Output () tree_widget . layout . max_width = \"310px\" tree_widget . overflow = \"auto\" left_widget . children = [ widgets . HBox ([ search_box , close_btn ]), tree_widget ] output = widgets . Output ( layout = widgets . Layout ( max_width = \"760px\" )) right_widget . children = [ output ] tree = Tree ( multiple_selection = False ) tree_dict = {} def search_box_callback ( text ): with tree_widget : if text . value == \"\" : print ( \"Loading...\" ) tree_widget . clear_output ( wait = True ) display ( tree ) else : tree_widget . clear_output () print ( \"Searching...\" ) tree_widget . clear_output ( wait = True ) sub_tree = search_api_tree ( text . value , tree_dict ) display ( sub_tree ) search_box . on_submit ( search_box_callback ) root_name = \"WhiteboxTools\" root_node = Node ( root_name ) tree . add_node ( root_node ) categories = {} def handle_tool_clicked ( event ): if event [ \"new\" ]: cur_node = event [ \"owner\" ] tool_name = cur_node . name with output : output . clear_output () tool_ui = tool_gui ( tools_dict [ tool_name ]) display ( tool_ui ) for key in tools_dict . keys (): category = tools_dict [ key ][ \"category\" ] if category not in categories . keys (): category_node = Node ( category , icon = folder_icon , opened = False ) root_node . add_node ( category_node ) categories [ category ] = category_node tool_node = Node ( key , icon = tool_icon ) category_node . add_node ( tool_node ) tree_dict [ key ] = tool_node tool_node . observe ( handle_tool_clicked , \"selected\" ) else : category_node = categories [ category ] tool_node = Node ( key , icon = tool_icon ) category_node . add_node ( tool_node ) tree_dict [ key ] = tool_node tool_node . observe ( handle_tool_clicked , \"selected\" ) with tree_widget : tree_widget . clear_output () display ( tree ) return full_widget clone_repo ( out_dir = '.' , unzip = True ) \u00b6 Clones the whiteboxgui GitHub repository. Parameters: Name Type Description Default out_dir str Output folder for the repo. Defaults to '.'. '.' unzip bool Whether to unzip the repository. Defaults to True. True Source code in whiteboxgui/whiteboxgui.py def clone_repo ( out_dir = \".\" , unzip = True ): \"\"\"Clones the whiteboxgui GitHub repository. Args: out_dir (str, optional): Output folder for the repo. Defaults to '.'. unzip (bool, optional): Whether to unzip the repository. Defaults to True. \"\"\" url = \"https://github.com/giswqs/whiteboxgui/archive/master.zip\" filename = \"whiteboxgui-master.zip\" download_from_url ( url , out_file_name = filename , out_dir = out_dir , unzip = unzip ) create_code_cell ( code = '' , where = 'below' ) \u00b6 Creates a code cell in the IPython Notebook. Parameters: Name Type Description Default code str Code to fill the new code cell with. Defaults to ''. '' where str Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. 'below' Source code in whiteboxgui/whiteboxgui.py def create_code_cell ( code = \"\" , where = \"below\" ): \"\"\"Creates a code cell in the IPython Notebook. Args: code (str, optional): Code to fill the new code cell with. Defaults to ''. where (str, optional): Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. \"\"\" import base64 from IPython.display import Javascript , display encoded_code = ( base64 . b64encode ( str . encode ( code ))) . decode () display ( Javascript ( \"\"\" var code = IPython.notebook.insert_cell_{0}('code'); code.set_text(atob(\"{1}\")); \"\"\" . format ( where , encoded_code ) ) ) download_from_url ( url , out_file_name = None , out_dir = '.' , unzip = True , verbose = False ) \u00b6 Download a file from a URL (e.g., https://github.com/giswqs/whitebox/raw/master/examples/testdata.zip) Parameters: Name Type Description Default url str The HTTP URL to download. required out_file_name str The output file name to use. Defaults to None. None out_dir str The output directory to use. Defaults to '.'. '.' unzip bool Whether to unzip the downloaded file if it is a zip file. Defaults to True. True verbose bool Whether to display or not the output of the function. Defaults to False. False Source code in whiteboxgui/whiteboxgui.py def download_from_url ( url , out_file_name = None , out_dir = \".\" , unzip = True , verbose = False ): \"\"\"Download a file from a URL (e.g., https://github.com/giswqs/whitebox/raw/master/examples/testdata.zip) Args: url (str): The HTTP URL to download. out_file_name (str, optional): The output file name to use. Defaults to None. out_dir (str, optional): The output directory to use. Defaults to '.'. unzip (bool, optional): Whether to unzip the downloaded file if it is a zip file. Defaults to True. verbose (bool, optional): Whether to display or not the output of the function. Defaults to False. \"\"\" import tarfile import urllib.request import zipfile in_file_name = os . path . basename ( url ) if out_file_name is None : out_file_name = in_file_name out_file_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name ) if verbose : print ( \"Downloading {} ...\" . format ( url )) try : urllib . request . urlretrieve ( url , out_file_path ) except Exception : raise Exception ( \"The URL is invalid. Please double check the URL.\" ) final_path = out_file_path if unzip : # if it is a zip file if \".zip\" in out_file_name : if verbose : print ( \"Unzipping {} ...\" . format ( out_file_name )) with zipfile . ZipFile ( out_file_path , \"r\" ) as zip_ref : zip_ref . extractall ( out_dir ) final_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name . replace ( \".zip\" , \"\" ) ) # if it is a tar file if \".tar\" in out_file_name : if verbose : print ( \"Unzipping {} ...\" . format ( out_file_name )) with tarfile . open ( out_file_path , \"r\" ) as tar_ref : tar_ref . extractall ( out_dir ) final_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name . replace ( \".tart\" , \"\" ) ) if verbose : print ( \"Data downloaded to: {} \" . format ( final_path )) return get_book_url ( tool_name , category ) \u00b6 Get the link to the help documentation of the tool. Parameters: Name Type Description Default tool_name str The name of the tool. required category str The category of the tool. required Returns: Type Description str The URL to help documentation. Source code in whiteboxgui/whiteboxgui.py def get_book_url ( tool_name , category ): \"\"\"Get the link to the help documentation of the tool. Args: tool_name (str): The name of the tool. category (str): The category of the tool. Returns: str: The URL to help documentation. \"\"\" prefix = \"https://jblindsay.github.io/wbt_book/available_tools\" url = \" {} / {} .html# {} \" . format ( prefix , category , tool_name ) return url get_github_url ( tool_name , category ) \u00b6 Get the link to the source code of the tool on GitHub. Parameters: Name Type Description Default tool_name str The name of the tool. required category str The category of the tool. required Returns: Type Description str The URL to source code. Source code in whiteboxgui/whiteboxgui.py def get_github_url ( tool_name , category ): \"\"\"Get the link to the source code of the tool on GitHub. Args: tool_name (str): The name of the tool. category (str): The category of the tool. Returns: str: The URL to source code. \"\"\" url = wbt . view_code ( tool_name ) . strip () return url get_tool_params ( tool_name ) \u00b6 Get parameters for a tool. Parameters: Name Type Description Default tool_name str The name of the tool. required Returns: Type Description dict The tool parameters as a dictionary. Source code in whiteboxgui/whiteboxgui.py def get_tool_params ( tool_name ): \"\"\"Get parameters for a tool. Args: tool_name (str): The name of the tool. Returns: dict: The tool parameters as a dictionary. \"\"\" out_str = wbt . tool_parameters ( tool_name ) start_index = out_str . index ( \"[\" ) + 1 end_index = len ( out_str . strip ()) - 2 params = out_str [ start_index : end_index ] sub_params = params . split ( '{\"name\"' ) param_list = [] for param in sub_params : param = param . strip () if len ( param ) > 0 : item = '\"name\"' + param item = item [: item . rfind ( \"}\" )] . strip () param_list . append ( item ) params_dict = {} for item in param_list : param_dict = {} item = item . replace ( \" (optional)\" , \"\" ) index_name = item . find ( \"name\" ) index_flags = item . find ( \"flags\" ) index_description = item . find ( \"description\" ) index_parameter_type = item . find ( \"parameter_type\" ) index_default_value = item . find ( \"default_value\" ) index_optional = item . find ( \"optional\" ) name = item [ index_name - 1 : index_flags - 2 ] . replace ( '\"name\":' , \"\" ) name = name . replace ( '\"' , \"\" ) param_dict [ \"name\" ] = name flags = item [ index_flags - 1 : index_description - 2 ] . replace ( '\"flags\":' , \"\" ) if ( '\"-i\"' in flags ) and ( \"--inputs\" in flags ): flags = \"inputs\" elif ( ( '\"-i\"' in flags ) and ( \"--input\" in flags ) and ( \"--dem\" in flags ) and ( tool_name . lower () != \"sink\" ) ): flags = \"dem\" elif ( '\"-i\"' in flags ) and ( \"--input\" in flags ): flags = \"i\" elif flags . count ( \"--\" ) == 1 : flags = flags . split ( \"--\" )[ 1 ][: - 2 ] elif flags . count ( \"--\" ) == 2 : flags = flags . split ( \"--\" )[ 2 ][: - 2 ] else : flags = flags . split ( \"-\" )[ 1 ][: - 2 ] param_dict [ \"flags\" ] = flags desc = item [ index_description - 1 : index_parameter_type - 2 ] . replace ( '\"description\":' , \"\" ) desc = desc . replace ( '\"' , \"\" ) param_dict [ \"description\" ] = desc param_type = item [ index_parameter_type - 1 : index_default_value - 2 ] . replace ( '\"parameter_type\":' , \"\" ) param_type = ast . literal_eval ( param_type ) param_dict [ \"parameter_type\" ] = param_type default_value = item [ index_default_value - 1 : index_optional - 2 ] . replace ( '\"default_value\":' , \"\" ) param_dict [ \"default_value\" ] = default_value optional = item [ index_optional - 1 :] . replace ( '\"optional\":' , \"\" ) param_dict [ \"optional\" ] = optional params_dict [ flags ] = param_dict return params_dict get_wbt_dict ( reset = False ) \u00b6 Generate a dictionary containing information for all tools. Parameters: Name Type Description Default reset bool Whether to recreate the json file containing the dictionary. Defaults to False. False Returns: Type Description dict The dictionary containing information for all tools. Source code in whiteboxgui/whiteboxgui.py def get_wbt_dict ( reset = False ): \"\"\"Generate a dictionary containing information for all tools. Args: reset (bool, optional): Whether to recreate the json file containing the dictionary. Defaults to False. Returns: dict: The dictionary containing information for all tools. \"\"\" wbt_dir = os . path . dirname ( pkg_resources . resource_filename ( \"whitebox\" , \"whitebox_tools.py\" ) ) wbt_py = os . path . join ( wbt_dir , \"whitebox_tools.py\" ) wbt_dict = os . path . join ( wbt_dir , \"whitebox_tools.json\" ) toolboxes = { \"# Data Tools #\" : \"Data Tools\" , \"# GIS Analysis #\" : \"GIS Analysis\" , \"# Geomorphometric Analysis #\" : \"Geomorphometric Analysis\" , \"# Hydrological Analysis #\" : \"Hydrological Analysis\" , \"# Image Processing Tools #\" : \"Image Processing Tools\" , \"# LiDAR Tools #\" : \"LiDAR Tools\" , \"# Math and Stats Tools #\" : \"Math and Stats Tools\" , \"# Stream Network Analysis #\" : \"Stream Network Analysis\" , } github_cls = { \"Data Tools\" : \"data_tools\" , \"GIS Analysis\" : \"gis_analysis\" , \"Geomorphometric Analysis\" : \"terrain_analysis\" , \"Hydrological Analysis\" : \"hydro_analysis\" , \"Image Processing Tools\" : \"image_analysis\" , \"LiDAR Tools\" : \"lidar_analysis\" , \"Math and Stats Tools\" : \"math_stat_analysis\" , \"Stream Network Analysis\" : \"stream_network_analysis\" , } book_cls = { \"Data Tools\" : \"data_tools\" , \"GIS Analysis\" : \"gis_analysis\" , \"Geomorphometric Analysis\" : \"geomorphometric_analysis\" , \"Hydrological Analysis\" : \"hydrological_analysis\" , \"Image Processing Tools\" : \"image_processing_tools\" , \"LiDAR Tools\" : \"lidar_tools\" , \"Math and Stats Tools\" : \"mathand_stats_tools\" , \"Stream Network Analysis\" : \"stream_network_analysis\" , } tools_dict = {} if ( not os . path . exists ( wbt_dict )) or reset : tool_labels = [] category = \"\" tool_index = 1 with open ( wbt_py ) as f : lines = f . readlines () for index , line in enumerate ( lines ): if index > 500 : line = line . strip () if line in toolboxes : category = toolboxes [ line ] if line . startswith ( \"def\" ): func_title = line . replace ( \"def\" , \"\" , 1 ) . strip () . split ( \"(\" )[ 0 ] func_name = to_camelcase ( func_title ) func_label = to_label ( func_title ) tool_labels . append ( func_label ) func_desc = lines [ index + 1 ] . replace ( '\"\"\"' , \"\" ) . strip () func_dict = {} func_dict [ \"name\" ] = func_name func_dict [ \"Name\" ] = to_camelcase ( func_name ) func_dict [ \"category\" ] = category func_dict [ \"label\" ] = func_label func_dict [ \"description\" ] = func_desc github_url = get_github_url ( func_name , github_cls [ category ]) book_url = get_book_url ( func_name , book_cls [ category ]) func_dict [ \"github\" ] = github_url func_dict [ \"book\" ] = book_url tool_index = tool_index + 1 func_params = get_tool_params ( func_name ) func_dict [ \"parameters\" ] = func_params tools_dict [ func_name ] = func_dict with open ( wbt_dict , \"w\" ) as fp : json . dump ( tools_dict , fp ) else : with open ( wbt_dict ) as fp : tools_dict = json . load ( fp ) return tools_dict in_colab_shell () \u00b6 Tests if the code is being executed within Google Colab. Source code in whiteboxgui/whiteboxgui.py def in_colab_shell (): \"\"\"Tests if the code is being executed within Google Colab.\"\"\" import sys if \"google.colab\" in sys . modules : return True else : return False search_api_tree ( keywords , api_tree ) \u00b6 Search Earth Engine API and return functions containing the specified keywords Parameters: Name Type Description Default keywords str The keywords to search for. required api_tree dict The dictionary containing the Earth Engine API tree. required Returns: Type Description object An ipytree object/widget. Source code in whiteboxgui/whiteboxgui.py def search_api_tree ( keywords , api_tree ): \"\"\"Search Earth Engine API and return functions containing the specified keywords Args: keywords (str): The keywords to search for. api_tree (dict): The dictionary containing the Earth Engine API tree. Returns: object: An ipytree object/widget. \"\"\" import warnings warnings . filterwarnings ( \"ignore\" ) sub_tree = Tree () for key in api_tree . keys (): if keywords . lower () in key . lower (): sub_tree . add_node ( api_tree [ key ]) return sub_tree show ( verbose = True , tree = False , reset = False ) \u00b6 Show the toolbox GUI. Parameters: Name Type Description Default verbose bool Whether to show progress info when the tool is running. Defaults to True. True tree bool Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False. False reset bool Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False. False Returns: Type Description object A toolbox GUI. Source code in whiteboxgui/whiteboxgui.py def show ( verbose = True , tree = False , reset = False ): \"\"\"Show the toolbox GUI. Args: verbose (bool, optional): Whether to show progress info when the tool is running. Defaults to True. tree (bool, optional): Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False. reset (bool, optional): Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False. Returns: object: A toolbox GUI. \"\"\" tools_dict = get_wbt_dict ( reset = reset ) if verbose : wbt . verbose = True else : wbt . verbose = False if in_colab_shell (): tree = False if tree : return build_toolbox_tree ( tools_dict ) else : return build_toolbox ( tools_dict ) to_camelcase ( name ) \u00b6 Convert snake_case name to CamelCase name. Parameters: Name Type Description Default name str The name of the tool. required Returns: Type Description str The CamelCase name of the tool. Source code in whiteboxgui/whiteboxgui.py def to_camelcase ( name ): \"\"\"Convert snake_case name to CamelCase name. Args: name (str): The name of the tool. Returns: str: The CamelCase name of the tool. \"\"\" return \"\" . join ( x . title () for x in name . split ( \"_\" )) to_label ( name ) \u00b6 Convert snake_case name to Title case label. Parameters: Name Type Description Default name str The name of the tool. required Returns: Type Description str The Title case name of the tool. Source code in whiteboxgui/whiteboxgui.py def to_label ( name ): \"\"\"Convert snake_case name to Title case label. Args: name (str): The name of the tool. Returns: str: The Title case name of the tool. \"\"\" return \" \" . join ( x . title () for x in name . split ( \"_\" )) to_snakecase ( name ) \u00b6 Convert CamelCase name to snake_case name. Parameters: Name Type Description Default name str The name of the tool. required Returns: Type Description str The snakecase name of the tool. Source code in whiteboxgui/whiteboxgui.py def to_snakecase ( name ): \"\"\"Convert CamelCase name to snake_case name. Args: name (str): The name of the tool. Returns: str: The snakecase name of the tool. \"\"\" s1 = re . sub ( \"(.)([A-Z][a-z]+)\" , r \"\\1_\\2\" , name ) return re . sub ( \"([a-z0-9])([A-Z])\" , r \"\\1_\\2\" , s1 ) . lower () tool_gui ( tool_dict , max_width = '420px' , max_height = '600px' ) \u00b6 Create a GUI for a tool based on the tool dictionary. Parameters: Name Type Description Default tool_dict dict The dictionary containing the tool info. required max_width str The max width of the tool dialog. '420px' max_height str The max height of the tool dialog. '600px' Returns: Type Description object An ipywidget object representing the tool interface. Source code in whiteboxgui/whiteboxgui.py def tool_gui ( tool_dict , max_width = \"420px\" , max_height = \"600px\" ): \"\"\"Create a GUI for a tool based on the tool dictionary. Args: tool_dict (dict): The dictionary containing the tool info. max_width (str, optional): The max width of the tool dialog. max_height (str, optional): The max height of the tool dialog. Returns: object: An ipywidget object representing the tool interface. \"\"\" tool_widget = widgets . VBox ( layout = widgets . Layout ( max_width = max_width , max_height = max_height ) ) children = [] args = {} required_inputs = [] style = { \"description_width\" : \"initial\" } max_width = str ( int ( max_width . replace ( \"px\" , \"\" )) - 10 ) + \"px\" header_width = str ( int ( max_width . replace ( \"px\" , \"\" )) - 104 ) + \"px\" header = widgets . Label ( value = f 'Current Tool: { tool_dict [ \"name\" ] } ' , style = style , layout = widgets . Layout ( width = header_width ), ) code_btn = widgets . Button ( description = \"View Code\" , layout = widgets . Layout ( width = \"100px\" ) ) children . append ( widgets . HBox ([ header , code_btn ])) desc = widgets . Textarea ( value = f 'Description: { tool_dict [ \"description\" ] } ' , layout = widgets . Layout ( width = \"410px\" , max_width = max_width ), disabled = True , ) children . append ( desc ) params = tool_dict [ \"parameters\" ] for param in params : items = params [ param ] required = \"\" if items [ \"optional\" ] == \"false\" : required = \"*\" required_inputs . append ( param ) label = items [ \"name\" ] + required param_type = items [ \"parameter_type\" ] default_value = None if ( items [ \"default_value\" ] != \"null\" ) and ( len ( items [ \"default_value\" ]) > 0 ): if \"false\" in items [ \"default_value\" ]: default_value = False elif \"true\" in items [ \"default_value\" ]: default_value = True else : default_value = items [ \"default_value\" ] . replace ( '\"' , \"\" ) layout = widgets . Layout ( width = \"500px\" , max_width = max_width ) if isinstance ( param_type , str ): # display(data_types[param_type]) if param_type == \"Boolean\" : var_widget = widgets . Checkbox ( description = label , style = style , layout = layout , value = default_value ) elif param_type in [ \"Directory\" , \"ExistingFile\" , \"ExistingFileOrFloat\" , \"FileList\" , \"NewFile\" , ]: var_widget = FileChooser ( title = label ) else : var_widget = widgets . Text ( description = label , style = style , layout = layout ) if default_value is not None : var_widget . value = str ( default_value ) args [ param ] = var_widget children . append ( var_widget ) elif isinstance ( param_type , dict ): if \"OptionList\" in param_type : var_widget = widgets . Dropdown ( options = param_type [ \"OptionList\" ], description = label , style = style , layout = layout , ) elif list ( param_type . keys ())[ 0 ] in [ \"Directory\" , \"ExistingFile\" , \"ExistingFileOrFloat\" , \"FileList\" , \"NewFile\" , ]: var_widget = FileChooser ( title = label ) else : var_widget = FileChooser ( title = label ) args [ param ] = var_widget children . append ( var_widget ) run_btn = widgets . Button ( description = \"Run\" , layout = widgets . Layout ( width = \"100px\" )) cancel_btn = widgets . Button ( description = \"Cancel\" , layout = widgets . Layout ( width = \"100px\" ) ) help_btn = widgets . Button ( description = \"Help\" , layout = widgets . Layout ( width = \"100px\" )) import_btn = widgets . Button ( description = \"Import\" , tooltip = \"Import the script to a new cell\" , layout = widgets . Layout ( width = \"98px\" ), ) tool_output = widgets . Output ( layout = widgets . Layout ( max_height = \"200px\" )) children . append ( widgets . HBox ([ run_btn , cancel_btn , help_btn , import_btn ])) children . append ( tool_output ) tool_widget . children = children def run_button_clicked ( b ): tool_output . clear_output () required_params = required_inputs . copy () args2 = [] for arg in args : line = \"\" if isinstance ( args [ arg ], FileChooser ): if arg in required_params and args [ arg ] . selected is None : with tool_output : print ( f \"Please provide inputs for required parameters.\" ) break elif arg in required_params : required_params . remove ( arg ) if arg == \"i\" : line = f \"- { arg } = { args [ arg ] . selected } \" else : line = f \"-- { arg } = { args [ arg ] . selected } \" elif isinstance ( args [ arg ], widgets . Text ): if arg in required_params and len ( args [ arg ] . value ) == 0 : with tool_output : print ( f \"Please provide inputs for required parameters.\" ) break elif arg in required_params : required_params . remove ( arg ) if args [ arg ] . value is not None and len ( args [ arg ] . value ) > 0 : line = f \"-- { arg } = { args [ arg ] . value } \" elif isinstance ( args [ arg ], widgets . Checkbox ): line = f \"-- { arg } = { args [ arg ] . value } \" args2 . append ( line ) if len ( required_params ) == 0 : with tool_output : wbt . run_tool ( tool_dict [ \"name\" ], args2 ) def help_button_clicked ( b ): import webbrowser tool_output . clear_output () with tool_output : html = widgets . HTML ( value = f '<a href= { tool_dict [ \"book\" ] } target=\"_blank\"> { tool_dict [ \"book\" ] } </a>' ) display ( html ) webbrowser . open_new_tab ( tool_dict [ \"book\" ]) def code_button_clicked ( b ): import webbrowser with tool_output : html = widgets . HTML ( value = f '<a href= { tool_dict [ \"github\" ] } target=\"_blank\"> { tool_dict [ \"github\" ] } </a>' ) display ( html ) webbrowser . open_new_tab ( tool_dict [ \"github\" ]) def cancel_btn_clicked ( b ): tool_output . clear_output () def import_button_clicked ( b ): tool_output . clear_output () required_params = required_inputs . copy () args2 = [] args3 = [] for arg in args : line = \"\" if isinstance ( args [ arg ], FileChooser ): if arg in required_params and args [ arg ] . selected is None : with tool_output : print ( f \"Please provide inputs for required parameters.\" ) break elif arg in required_params : required_params . remove ( arg ) if arg == \"i\" : line = f \"- { arg } = { args [ arg ] . selected } \" else : line = f \"-- { arg } = { args [ arg ] . selected } \" if args [ arg ] . selected is not None : args3 . append ( f \" { arg } =' { args [ arg ] . selected } '\" ) elif isinstance ( args [ arg ], widgets . Text ): if arg in required_params and len ( args [ arg ] . value ) == 0 : with tool_output : print ( f \"Please provide inputs for required parameters.\" ) break elif arg in required_params : required_params . remove ( arg ) if args [ arg ] . value is not None and len ( args [ arg ] . value ) > 0 : line = f \"-- { arg } = { args [ arg ] . value } \" args3 . append ( f \" { arg } =' { args [ arg ] . value } '\" ) elif isinstance ( args [ arg ], widgets . Checkbox ): line = f \"-- { arg } = { args [ arg ] . value } \" args3 . append ( f \" { arg } = { args [ arg ] . value } \" ) args2 . append ( line ) if len ( required_params ) == 0 : content = [] content . append ( \"import whitebox\" ) content . append ( \"wbt = whitebox.WhiteboxTools()\" ) content . append ( f \"wbt. { to_snakecase ( tool_dict [ 'name' ]) } ( { ', ' . join ( args3 ) } )\" ) with tool_output : for line in content : print ( line ) create_code_cell ( \" \\n \" . join ( content )) import_btn . on_click ( import_button_clicked ) run_btn . on_click ( run_button_clicked ) help_btn . on_click ( help_button_clicked ) code_btn . on_click ( code_button_clicked ) cancel_btn . on_click ( cancel_btn_clicked ) return tool_widget update_package () \u00b6 Updates the whiteboxgui package from the GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. Source code in whiteboxgui/whiteboxgui.py def update_package (): \"\"\"Updates the whiteboxgui package from the GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. \"\"\" import shutil try : download_dir = os . getcwd () clone_repo ( out_dir = download_dir ) pkg_dir = os . path . join ( download_dir , \"whiteboxgui-master\" ) work_dir = os . getcwd () os . chdir ( pkg_dir ) if shutil . which ( \"pip\" ) is None : cmd = \"pip3 install .\" else : cmd = \"pip install .\" os . system ( cmd ) os . chdir ( work_dir ) os . remove ( pkg_dir + \".zip\" ) shutil . rmtree ( pkg_dir ) print ( \" \\n Please comment out 'whiteboxgui.update_package()' and restart the kernel to take effect: \\n Jupyter menu -> Kernel -> Restart & Clear Output\" ) except Exception as e : raise Exception ( e )","title":"whiteboxgui module"},{"location":"whiteboxgui/#whiteboxgui-module","text":"","title":"whiteboxgui module"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui","text":"Main module.","title":"whiteboxgui.whiteboxgui"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.build_toolbox","text":"Build the toolbox for WhiteboxTools. Parameters: Name Type Description Default tools_dict dict A dictionary containing information for all tools. required max_width str The maximum width of the widget. '1080px' max_height str The maximum height of the widget. '600px' Returns: Type Description object An ipywidget representing the toolbox. Source code in whiteboxgui/whiteboxgui.py def build_toolbox ( tools_dict , max_width = \"1080px\" , max_height = \"600px\" ): \"\"\"Build the toolbox for WhiteboxTools. Args: tools_dict (dict): A dictionary containing information for all tools. max_width (str, optional): The maximum width of the widget. max_height (str, optional): The maximum height of the widget. Returns: object: An ipywidget representing the toolbox. \"\"\" left_widget = widgets . VBox ( layout = widgets . Layout ( min_width = \"175px\" )) center_widget = widgets . VBox ( layout = widgets . Layout ( min_width = \"200px\" , max_width = \"200px\" ) ) right_widget = widgets . Output ( layout = widgets . Layout ( width = \"630px\" , max_height = max_height ) ) full_widget = widgets . HBox ( [ left_widget , center_widget , right_widget ], layout = widgets . Layout ( max_width = max_width , max_height = max_height ), ) search_widget = widgets . Text ( placeholder = \"Search tools ...\" , layout = widgets . Layout ( width = \"170px\" ) ) label_widget = widgets . Label ( layout = widgets . Layout ( width = \"170px\" )) label_widget . value = f \" { len ( tools_dict ) } Available Tools\" close_btn = widgets . Button ( description = \"Close Toolbox\" , icon = \"close\" , layout = widgets . Layout ( width = \"170px\" ) ) categories = {} categories [ \"All Tools\" ] = [] for key in tools_dict . keys (): category = tools_dict [ key ][ \"category\" ] if category not in categories . keys (): categories [ category ] = [] categories [ category ] . append ( tools_dict [ key ][ \"name\" ]) categories [ \"All Tools\" ] . append ( tools_dict [ key ][ \"name\" ]) options = list ( categories . keys ()) all_tools = categories [ \"All Tools\" ] all_tools . sort () category_widget = widgets . Select ( options = options , layout = widgets . Layout ( width = \"170px\" , height = \"165px\" ) ) tools_widget = widgets . Select ( options = [], layout = widgets . Layout ( width = \"195px\" , height = \"400px\" ) ) def category_selected ( change ): if change [ \"new\" ]: selected = change [ \"owner\" ] . value options = categories [ selected ] options . sort () tools_widget . options = options label_widget . value = f \" { len ( options ) } Available Tools\" category_widget . observe ( category_selected , \"value\" ) def tool_selected ( change ): if change [ \"new\" ]: selected = change [ \"owner\" ] . value tool_dict = tools_dict [ selected ] with right_widget : right_widget . clear_output () display ( tool_gui ( tool_dict , max_height = max_height )) tools_widget . observe ( tool_selected , \"value\" ) def search_changed ( change ): if change [ \"new\" ]: keyword = change [ \"owner\" ] . value if len ( keyword ) > 0 : selected_tools = [] for tool in all_tools : if keyword . lower () in tool . lower (): selected_tools . append ( tool ) if len ( selected_tools ) > 0 : tools_widget . options = selected_tools label_widget . value = f \" { len ( selected_tools ) } Available Tools\" else : tools_widget . options = all_tools label_widget . value = f \" { len ( tools_dict ) } Available Tools\" search_widget . observe ( search_changed , \"value\" ) def close_btn_clicked ( b ): full_widget . close () close_btn . on_click ( close_btn_clicked ) category_widget . value = list ( categories . keys ())[ 0 ] tools_widget . options = all_tools left_widget . children = [ category_widget , search_widget , label_widget , close_btn ] center_widget . children = [ tools_widget ] return full_widget","title":"build_toolbox()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.build_toolbox_tree","text":"Build the toolbox for WhiteboxTools. Parameters: Name Type Description Default tools_dict dict A dictionary containing information for all tools. required folder_icon str The font-awesome icon for tool categories. Defaults to \"folder\". 'folder' tool_icon str The font-awesome icon for tools. Defaults to \"wrench\". 'wrench' Returns: Type Description object An ipywidget representing the toolbox. Source code in whiteboxgui/whiteboxgui.py def build_toolbox_tree ( tools_dict , folder_icon = \"folder\" , tool_icon = \"wrench\" ): \"\"\"Build the toolbox for WhiteboxTools. Args: tools_dict (dict): A dictionary containing information for all tools. folder_icon (str, optional): The font-awesome icon for tool categories. Defaults to \"folder\". tool_icon (str, optional): The font-awesome icon for tools. Defaults to \"wrench\". Returns: object: An ipywidget representing the toolbox. \"\"\" left_widget = widgets . VBox () right_widget = widgets . VBox () full_widget = widgets . HBox ([ left_widget , right_widget ]) search_description = f \" { len ( tools_dict ) } tools available. Search tools ...\" search_box = widgets . Text ( placeholder = search_description ) search_box . layout . width = \"270px\" close_btn = widgets . Button ( icon = \"close\" , layout = widgets . Layout ( width = \"32px\" )) def close_btn_clicked ( b ): full_widget . close () close_btn . on_click ( close_btn_clicked ) tree_widget = widgets . Output () tree_widget . layout . max_width = \"310px\" tree_widget . overflow = \"auto\" left_widget . children = [ widgets . HBox ([ search_box , close_btn ]), tree_widget ] output = widgets . Output ( layout = widgets . Layout ( max_width = \"760px\" )) right_widget . children = [ output ] tree = Tree ( multiple_selection = False ) tree_dict = {} def search_box_callback ( text ): with tree_widget : if text . value == \"\" : print ( \"Loading...\" ) tree_widget . clear_output ( wait = True ) display ( tree ) else : tree_widget . clear_output () print ( \"Searching...\" ) tree_widget . clear_output ( wait = True ) sub_tree = search_api_tree ( text . value , tree_dict ) display ( sub_tree ) search_box . on_submit ( search_box_callback ) root_name = \"WhiteboxTools\" root_node = Node ( root_name ) tree . add_node ( root_node ) categories = {} def handle_tool_clicked ( event ): if event [ \"new\" ]: cur_node = event [ \"owner\" ] tool_name = cur_node . name with output : output . clear_output () tool_ui = tool_gui ( tools_dict [ tool_name ]) display ( tool_ui ) for key in tools_dict . keys (): category = tools_dict [ key ][ \"category\" ] if category not in categories . keys (): category_node = Node ( category , icon = folder_icon , opened = False ) root_node . add_node ( category_node ) categories [ category ] = category_node tool_node = Node ( key , icon = tool_icon ) category_node . add_node ( tool_node ) tree_dict [ key ] = tool_node tool_node . observe ( handle_tool_clicked , \"selected\" ) else : category_node = categories [ category ] tool_node = Node ( key , icon = tool_icon ) category_node . add_node ( tool_node ) tree_dict [ key ] = tool_node tool_node . observe ( handle_tool_clicked , \"selected\" ) with tree_widget : tree_widget . clear_output () display ( tree ) return full_widget","title":"build_toolbox_tree()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.clone_repo","text":"Clones the whiteboxgui GitHub repository. Parameters: Name Type Description Default out_dir str Output folder for the repo. Defaults to '.'. '.' unzip bool Whether to unzip the repository. Defaults to True. True Source code in whiteboxgui/whiteboxgui.py def clone_repo ( out_dir = \".\" , unzip = True ): \"\"\"Clones the whiteboxgui GitHub repository. Args: out_dir (str, optional): Output folder for the repo. Defaults to '.'. unzip (bool, optional): Whether to unzip the repository. Defaults to True. \"\"\" url = \"https://github.com/giswqs/whiteboxgui/archive/master.zip\" filename = \"whiteboxgui-master.zip\" download_from_url ( url , out_file_name = filename , out_dir = out_dir , unzip = unzip )","title":"clone_repo()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.create_code_cell","text":"Creates a code cell in the IPython Notebook. Parameters: Name Type Description Default code str Code to fill the new code cell with. Defaults to ''. '' where str Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. 'below' Source code in whiteboxgui/whiteboxgui.py def create_code_cell ( code = \"\" , where = \"below\" ): \"\"\"Creates a code cell in the IPython Notebook. Args: code (str, optional): Code to fill the new code cell with. Defaults to ''. where (str, optional): Where to add the new code cell. It can be one of the following: above, below, at_bottom. Defaults to 'below'. \"\"\" import base64 from IPython.display import Javascript , display encoded_code = ( base64 . b64encode ( str . encode ( code ))) . decode () display ( Javascript ( \"\"\" var code = IPython.notebook.insert_cell_{0}('code'); code.set_text(atob(\"{1}\")); \"\"\" . format ( where , encoded_code ) ) )","title":"create_code_cell()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.download_from_url","text":"Download a file from a URL (e.g., https://github.com/giswqs/whitebox/raw/master/examples/testdata.zip) Parameters: Name Type Description Default url str The HTTP URL to download. required out_file_name str The output file name to use. Defaults to None. None out_dir str The output directory to use. Defaults to '.'. '.' unzip bool Whether to unzip the downloaded file if it is a zip file. Defaults to True. True verbose bool Whether to display or not the output of the function. Defaults to False. False Source code in whiteboxgui/whiteboxgui.py def download_from_url ( url , out_file_name = None , out_dir = \".\" , unzip = True , verbose = False ): \"\"\"Download a file from a URL (e.g., https://github.com/giswqs/whitebox/raw/master/examples/testdata.zip) Args: url (str): The HTTP URL to download. out_file_name (str, optional): The output file name to use. Defaults to None. out_dir (str, optional): The output directory to use. Defaults to '.'. unzip (bool, optional): Whether to unzip the downloaded file if it is a zip file. Defaults to True. verbose (bool, optional): Whether to display or not the output of the function. Defaults to False. \"\"\" import tarfile import urllib.request import zipfile in_file_name = os . path . basename ( url ) if out_file_name is None : out_file_name = in_file_name out_file_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name ) if verbose : print ( \"Downloading {} ...\" . format ( url )) try : urllib . request . urlretrieve ( url , out_file_path ) except Exception : raise Exception ( \"The URL is invalid. Please double check the URL.\" ) final_path = out_file_path if unzip : # if it is a zip file if \".zip\" in out_file_name : if verbose : print ( \"Unzipping {} ...\" . format ( out_file_name )) with zipfile . ZipFile ( out_file_path , \"r\" ) as zip_ref : zip_ref . extractall ( out_dir ) final_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name . replace ( \".zip\" , \"\" ) ) # if it is a tar file if \".tar\" in out_file_name : if verbose : print ( \"Unzipping {} ...\" . format ( out_file_name )) with tarfile . open ( out_file_path , \"r\" ) as tar_ref : tar_ref . extractall ( out_dir ) final_path = os . path . join ( os . path . abspath ( out_dir ), out_file_name . replace ( \".tart\" , \"\" ) ) if verbose : print ( \"Data downloaded to: {} \" . format ( final_path )) return","title":"download_from_url()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.get_book_url","text":"Get the link to the help documentation of the tool. Parameters: Name Type Description Default tool_name str The name of the tool. required category str The category of the tool. required Returns: Type Description str The URL to help documentation. Source code in whiteboxgui/whiteboxgui.py def get_book_url ( tool_name , category ): \"\"\"Get the link to the help documentation of the tool. Args: tool_name (str): The name of the tool. category (str): The category of the tool. Returns: str: The URL to help documentation. \"\"\" prefix = \"https://jblindsay.github.io/wbt_book/available_tools\" url = \" {} / {} .html# {} \" . format ( prefix , category , tool_name ) return url","title":"get_book_url()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.get_github_url","text":"Get the link to the source code of the tool on GitHub. Parameters: Name Type Description Default tool_name str The name of the tool. required category str The category of the tool. required Returns: Type Description str The URL to source code. Source code in whiteboxgui/whiteboxgui.py def get_github_url ( tool_name , category ): \"\"\"Get the link to the source code of the tool on GitHub. Args: tool_name (str): The name of the tool. category (str): The category of the tool. Returns: str: The URL to source code. \"\"\" url = wbt . view_code ( tool_name ) . strip () return url","title":"get_github_url()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.get_tool_params","text":"Get parameters for a tool. Parameters: Name Type Description Default tool_name str The name of the tool. required Returns: Type Description dict The tool parameters as a dictionary. Source code in whiteboxgui/whiteboxgui.py def get_tool_params ( tool_name ): \"\"\"Get parameters for a tool. Args: tool_name (str): The name of the tool. Returns: dict: The tool parameters as a dictionary. \"\"\" out_str = wbt . tool_parameters ( tool_name ) start_index = out_str . index ( \"[\" ) + 1 end_index = len ( out_str . strip ()) - 2 params = out_str [ start_index : end_index ] sub_params = params . split ( '{\"name\"' ) param_list = [] for param in sub_params : param = param . strip () if len ( param ) > 0 : item = '\"name\"' + param item = item [: item . rfind ( \"}\" )] . strip () param_list . append ( item ) params_dict = {} for item in param_list : param_dict = {} item = item . replace ( \" (optional)\" , \"\" ) index_name = item . find ( \"name\" ) index_flags = item . find ( \"flags\" ) index_description = item . find ( \"description\" ) index_parameter_type = item . find ( \"parameter_type\" ) index_default_value = item . find ( \"default_value\" ) index_optional = item . find ( \"optional\" ) name = item [ index_name - 1 : index_flags - 2 ] . replace ( '\"name\":' , \"\" ) name = name . replace ( '\"' , \"\" ) param_dict [ \"name\" ] = name flags = item [ index_flags - 1 : index_description - 2 ] . replace ( '\"flags\":' , \"\" ) if ( '\"-i\"' in flags ) and ( \"--inputs\" in flags ): flags = \"inputs\" elif ( ( '\"-i\"' in flags ) and ( \"--input\" in flags ) and ( \"--dem\" in flags ) and ( tool_name . lower () != \"sink\" ) ): flags = \"dem\" elif ( '\"-i\"' in flags ) and ( \"--input\" in flags ): flags = \"i\" elif flags . count ( \"--\" ) == 1 : flags = flags . split ( \"--\" )[ 1 ][: - 2 ] elif flags . count ( \"--\" ) == 2 : flags = flags . split ( \"--\" )[ 2 ][: - 2 ] else : flags = flags . split ( \"-\" )[ 1 ][: - 2 ] param_dict [ \"flags\" ] = flags desc = item [ index_description - 1 : index_parameter_type - 2 ] . replace ( '\"description\":' , \"\" ) desc = desc . replace ( '\"' , \"\" ) param_dict [ \"description\" ] = desc param_type = item [ index_parameter_type - 1 : index_default_value - 2 ] . replace ( '\"parameter_type\":' , \"\" ) param_type = ast . literal_eval ( param_type ) param_dict [ \"parameter_type\" ] = param_type default_value = item [ index_default_value - 1 : index_optional - 2 ] . replace ( '\"default_value\":' , \"\" ) param_dict [ \"default_value\" ] = default_value optional = item [ index_optional - 1 :] . replace ( '\"optional\":' , \"\" ) param_dict [ \"optional\" ] = optional params_dict [ flags ] = param_dict return params_dict","title":"get_tool_params()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.get_wbt_dict","text":"Generate a dictionary containing information for all tools. Parameters: Name Type Description Default reset bool Whether to recreate the json file containing the dictionary. Defaults to False. False Returns: Type Description dict The dictionary containing information for all tools. Source code in whiteboxgui/whiteboxgui.py def get_wbt_dict ( reset = False ): \"\"\"Generate a dictionary containing information for all tools. Args: reset (bool, optional): Whether to recreate the json file containing the dictionary. Defaults to False. Returns: dict: The dictionary containing information for all tools. \"\"\" wbt_dir = os . path . dirname ( pkg_resources . resource_filename ( \"whitebox\" , \"whitebox_tools.py\" ) ) wbt_py = os . path . join ( wbt_dir , \"whitebox_tools.py\" ) wbt_dict = os . path . join ( wbt_dir , \"whitebox_tools.json\" ) toolboxes = { \"# Data Tools #\" : \"Data Tools\" , \"# GIS Analysis #\" : \"GIS Analysis\" , \"# Geomorphometric Analysis #\" : \"Geomorphometric Analysis\" , \"# Hydrological Analysis #\" : \"Hydrological Analysis\" , \"# Image Processing Tools #\" : \"Image Processing Tools\" , \"# LiDAR Tools #\" : \"LiDAR Tools\" , \"# Math and Stats Tools #\" : \"Math and Stats Tools\" , \"# Stream Network Analysis #\" : \"Stream Network Analysis\" , } github_cls = { \"Data Tools\" : \"data_tools\" , \"GIS Analysis\" : \"gis_analysis\" , \"Geomorphometric Analysis\" : \"terrain_analysis\" , \"Hydrological Analysis\" : \"hydro_analysis\" , \"Image Processing Tools\" : \"image_analysis\" , \"LiDAR Tools\" : \"lidar_analysis\" , \"Math and Stats Tools\" : \"math_stat_analysis\" , \"Stream Network Analysis\" : \"stream_network_analysis\" , } book_cls = { \"Data Tools\" : \"data_tools\" , \"GIS Analysis\" : \"gis_analysis\" , \"Geomorphometric Analysis\" : \"geomorphometric_analysis\" , \"Hydrological Analysis\" : \"hydrological_analysis\" , \"Image Processing Tools\" : \"image_processing_tools\" , \"LiDAR Tools\" : \"lidar_tools\" , \"Math and Stats Tools\" : \"mathand_stats_tools\" , \"Stream Network Analysis\" : \"stream_network_analysis\" , } tools_dict = {} if ( not os . path . exists ( wbt_dict )) or reset : tool_labels = [] category = \"\" tool_index = 1 with open ( wbt_py ) as f : lines = f . readlines () for index , line in enumerate ( lines ): if index > 500 : line = line . strip () if line in toolboxes : category = toolboxes [ line ] if line . startswith ( \"def\" ): func_title = line . replace ( \"def\" , \"\" , 1 ) . strip () . split ( \"(\" )[ 0 ] func_name = to_camelcase ( func_title ) func_label = to_label ( func_title ) tool_labels . append ( func_label ) func_desc = lines [ index + 1 ] . replace ( '\"\"\"' , \"\" ) . strip () func_dict = {} func_dict [ \"name\" ] = func_name func_dict [ \"Name\" ] = to_camelcase ( func_name ) func_dict [ \"category\" ] = category func_dict [ \"label\" ] = func_label func_dict [ \"description\" ] = func_desc github_url = get_github_url ( func_name , github_cls [ category ]) book_url = get_book_url ( func_name , book_cls [ category ]) func_dict [ \"github\" ] = github_url func_dict [ \"book\" ] = book_url tool_index = tool_index + 1 func_params = get_tool_params ( func_name ) func_dict [ \"parameters\" ] = func_params tools_dict [ func_name ] = func_dict with open ( wbt_dict , \"w\" ) as fp : json . dump ( tools_dict , fp ) else : with open ( wbt_dict ) as fp : tools_dict = json . load ( fp ) return tools_dict","title":"get_wbt_dict()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.in_colab_shell","text":"Tests if the code is being executed within Google Colab. Source code in whiteboxgui/whiteboxgui.py def in_colab_shell (): \"\"\"Tests if the code is being executed within Google Colab.\"\"\" import sys if \"google.colab\" in sys . modules : return True else : return False","title":"in_colab_shell()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.search_api_tree","text":"Search Earth Engine API and return functions containing the specified keywords Parameters: Name Type Description Default keywords str The keywords to search for. required api_tree dict The dictionary containing the Earth Engine API tree. required Returns: Type Description object An ipytree object/widget. Source code in whiteboxgui/whiteboxgui.py def search_api_tree ( keywords , api_tree ): \"\"\"Search Earth Engine API and return functions containing the specified keywords Args: keywords (str): The keywords to search for. api_tree (dict): The dictionary containing the Earth Engine API tree. Returns: object: An ipytree object/widget. \"\"\" import warnings warnings . filterwarnings ( \"ignore\" ) sub_tree = Tree () for key in api_tree . keys (): if keywords . lower () in key . lower (): sub_tree . add_node ( api_tree [ key ]) return sub_tree","title":"search_api_tree()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.show","text":"Show the toolbox GUI. Parameters: Name Type Description Default verbose bool Whether to show progress info when the tool is running. Defaults to True. True tree bool Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False. False reset bool Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False. False Returns: Type Description object A toolbox GUI. Source code in whiteboxgui/whiteboxgui.py def show ( verbose = True , tree = False , reset = False ): \"\"\"Show the toolbox GUI. Args: verbose (bool, optional): Whether to show progress info when the tool is running. Defaults to True. tree (bool, optional): Whether to use the tree mode toolbox built using ipytree rather than ipywidgets. Defaults to False. reset (bool, optional): Whether to regenerate the json file with the dictionary containing the information for all tools. Defaults to False. Returns: object: A toolbox GUI. \"\"\" tools_dict = get_wbt_dict ( reset = reset ) if verbose : wbt . verbose = True else : wbt . verbose = False if in_colab_shell (): tree = False if tree : return build_toolbox_tree ( tools_dict ) else : return build_toolbox ( tools_dict )","title":"show()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.to_camelcase","text":"Convert snake_case name to CamelCase name. Parameters: Name Type Description Default name str The name of the tool. required Returns: Type Description str The CamelCase name of the tool. Source code in whiteboxgui/whiteboxgui.py def to_camelcase ( name ): \"\"\"Convert snake_case name to CamelCase name. Args: name (str): The name of the tool. Returns: str: The CamelCase name of the tool. \"\"\" return \"\" . join ( x . title () for x in name . split ( \"_\" ))","title":"to_camelcase()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.to_label","text":"Convert snake_case name to Title case label. Parameters: Name Type Description Default name str The name of the tool. required Returns: Type Description str The Title case name of the tool. Source code in whiteboxgui/whiteboxgui.py def to_label ( name ): \"\"\"Convert snake_case name to Title case label. Args: name (str): The name of the tool. Returns: str: The Title case name of the tool. \"\"\" return \" \" . join ( x . title () for x in name . split ( \"_\" ))","title":"to_label()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.to_snakecase","text":"Convert CamelCase name to snake_case name. Parameters: Name Type Description Default name str The name of the tool. required Returns: Type Description str The snakecase name of the tool. Source code in whiteboxgui/whiteboxgui.py def to_snakecase ( name ): \"\"\"Convert CamelCase name to snake_case name. Args: name (str): The name of the tool. Returns: str: The snakecase name of the tool. \"\"\" s1 = re . sub ( \"(.)([A-Z][a-z]+)\" , r \"\\1_\\2\" , name ) return re . sub ( \"([a-z0-9])([A-Z])\" , r \"\\1_\\2\" , s1 ) . lower ()","title":"to_snakecase()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.tool_gui","text":"Create a GUI for a tool based on the tool dictionary. Parameters: Name Type Description Default tool_dict dict The dictionary containing the tool info. required max_width str The max width of the tool dialog. '420px' max_height str The max height of the tool dialog. '600px' Returns: Type Description object An ipywidget object representing the tool interface. Source code in whiteboxgui/whiteboxgui.py def tool_gui ( tool_dict , max_width = \"420px\" , max_height = \"600px\" ): \"\"\"Create a GUI for a tool based on the tool dictionary. Args: tool_dict (dict): The dictionary containing the tool info. max_width (str, optional): The max width of the tool dialog. max_height (str, optional): The max height of the tool dialog. Returns: object: An ipywidget object representing the tool interface. \"\"\" tool_widget = widgets . VBox ( layout = widgets . Layout ( max_width = max_width , max_height = max_height ) ) children = [] args = {} required_inputs = [] style = { \"description_width\" : \"initial\" } max_width = str ( int ( max_width . replace ( \"px\" , \"\" )) - 10 ) + \"px\" header_width = str ( int ( max_width . replace ( \"px\" , \"\" )) - 104 ) + \"px\" header = widgets . Label ( value = f 'Current Tool: { tool_dict [ \"name\" ] } ' , style = style , layout = widgets . Layout ( width = header_width ), ) code_btn = widgets . Button ( description = \"View Code\" , layout = widgets . Layout ( width = \"100px\" ) ) children . append ( widgets . HBox ([ header , code_btn ])) desc = widgets . Textarea ( value = f 'Description: { tool_dict [ \"description\" ] } ' , layout = widgets . Layout ( width = \"410px\" , max_width = max_width ), disabled = True , ) children . append ( desc ) params = tool_dict [ \"parameters\" ] for param in params : items = params [ param ] required = \"\" if items [ \"optional\" ] == \"false\" : required = \"*\" required_inputs . append ( param ) label = items [ \"name\" ] + required param_type = items [ \"parameter_type\" ] default_value = None if ( items [ \"default_value\" ] != \"null\" ) and ( len ( items [ \"default_value\" ]) > 0 ): if \"false\" in items [ \"default_value\" ]: default_value = False elif \"true\" in items [ \"default_value\" ]: default_value = True else : default_value = items [ \"default_value\" ] . replace ( '\"' , \"\" ) layout = widgets . Layout ( width = \"500px\" , max_width = max_width ) if isinstance ( param_type , str ): # display(data_types[param_type]) if param_type == \"Boolean\" : var_widget = widgets . Checkbox ( description = label , style = style , layout = layout , value = default_value ) elif param_type in [ \"Directory\" , \"ExistingFile\" , \"ExistingFileOrFloat\" , \"FileList\" , \"NewFile\" , ]: var_widget = FileChooser ( title = label ) else : var_widget = widgets . Text ( description = label , style = style , layout = layout ) if default_value is not None : var_widget . value = str ( default_value ) args [ param ] = var_widget children . append ( var_widget ) elif isinstance ( param_type , dict ): if \"OptionList\" in param_type : var_widget = widgets . Dropdown ( options = param_type [ \"OptionList\" ], description = label , style = style , layout = layout , ) elif list ( param_type . keys ())[ 0 ] in [ \"Directory\" , \"ExistingFile\" , \"ExistingFileOrFloat\" , \"FileList\" , \"NewFile\" , ]: var_widget = FileChooser ( title = label ) else : var_widget = FileChooser ( title = label ) args [ param ] = var_widget children . append ( var_widget ) run_btn = widgets . Button ( description = \"Run\" , layout = widgets . Layout ( width = \"100px\" )) cancel_btn = widgets . Button ( description = \"Cancel\" , layout = widgets . Layout ( width = \"100px\" ) ) help_btn = widgets . Button ( description = \"Help\" , layout = widgets . Layout ( width = \"100px\" )) import_btn = widgets . Button ( description = \"Import\" , tooltip = \"Import the script to a new cell\" , layout = widgets . Layout ( width = \"98px\" ), ) tool_output = widgets . Output ( layout = widgets . Layout ( max_height = \"200px\" )) children . append ( widgets . HBox ([ run_btn , cancel_btn , help_btn , import_btn ])) children . append ( tool_output ) tool_widget . children = children def run_button_clicked ( b ): tool_output . clear_output () required_params = required_inputs . copy () args2 = [] for arg in args : line = \"\" if isinstance ( args [ arg ], FileChooser ): if arg in required_params and args [ arg ] . selected is None : with tool_output : print ( f \"Please provide inputs for required parameters.\" ) break elif arg in required_params : required_params . remove ( arg ) if arg == \"i\" : line = f \"- { arg } = { args [ arg ] . selected } \" else : line = f \"-- { arg } = { args [ arg ] . selected } \" elif isinstance ( args [ arg ], widgets . Text ): if arg in required_params and len ( args [ arg ] . value ) == 0 : with tool_output : print ( f \"Please provide inputs for required parameters.\" ) break elif arg in required_params : required_params . remove ( arg ) if args [ arg ] . value is not None and len ( args [ arg ] . value ) > 0 : line = f \"-- { arg } = { args [ arg ] . value } \" elif isinstance ( args [ arg ], widgets . Checkbox ): line = f \"-- { arg } = { args [ arg ] . value } \" args2 . append ( line ) if len ( required_params ) == 0 : with tool_output : wbt . run_tool ( tool_dict [ \"name\" ], args2 ) def help_button_clicked ( b ): import webbrowser tool_output . clear_output () with tool_output : html = widgets . HTML ( value = f '<a href= { tool_dict [ \"book\" ] } target=\"_blank\"> { tool_dict [ \"book\" ] } </a>' ) display ( html ) webbrowser . open_new_tab ( tool_dict [ \"book\" ]) def code_button_clicked ( b ): import webbrowser with tool_output : html = widgets . HTML ( value = f '<a href= { tool_dict [ \"github\" ] } target=\"_blank\"> { tool_dict [ \"github\" ] } </a>' ) display ( html ) webbrowser . open_new_tab ( tool_dict [ \"github\" ]) def cancel_btn_clicked ( b ): tool_output . clear_output () def import_button_clicked ( b ): tool_output . clear_output () required_params = required_inputs . copy () args2 = [] args3 = [] for arg in args : line = \"\" if isinstance ( args [ arg ], FileChooser ): if arg in required_params and args [ arg ] . selected is None : with tool_output : print ( f \"Please provide inputs for required parameters.\" ) break elif arg in required_params : required_params . remove ( arg ) if arg == \"i\" : line = f \"- { arg } = { args [ arg ] . selected } \" else : line = f \"-- { arg } = { args [ arg ] . selected } \" if args [ arg ] . selected is not None : args3 . append ( f \" { arg } =' { args [ arg ] . selected } '\" ) elif isinstance ( args [ arg ], widgets . Text ): if arg in required_params and len ( args [ arg ] . value ) == 0 : with tool_output : print ( f \"Please provide inputs for required parameters.\" ) break elif arg in required_params : required_params . remove ( arg ) if args [ arg ] . value is not None and len ( args [ arg ] . value ) > 0 : line = f \"-- { arg } = { args [ arg ] . value } \" args3 . append ( f \" { arg } =' { args [ arg ] . value } '\" ) elif isinstance ( args [ arg ], widgets . Checkbox ): line = f \"-- { arg } = { args [ arg ] . value } \" args3 . append ( f \" { arg } = { args [ arg ] . value } \" ) args2 . append ( line ) if len ( required_params ) == 0 : content = [] content . append ( \"import whitebox\" ) content . append ( \"wbt = whitebox.WhiteboxTools()\" ) content . append ( f \"wbt. { to_snakecase ( tool_dict [ 'name' ]) } ( { ', ' . join ( args3 ) } )\" ) with tool_output : for line in content : print ( line ) create_code_cell ( \" \\n \" . join ( content )) import_btn . on_click ( import_button_clicked ) run_btn . on_click ( run_button_clicked ) help_btn . on_click ( help_button_clicked ) code_btn . on_click ( code_button_clicked ) cancel_btn . on_click ( cancel_btn_clicked ) return tool_widget","title":"tool_gui()"},{"location":"whiteboxgui/#whiteboxgui.whiteboxgui.update_package","text":"Updates the whiteboxgui package from the GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. Source code in whiteboxgui/whiteboxgui.py def update_package (): \"\"\"Updates the whiteboxgui package from the GitHub repository without the need to use pip or conda. In this way, I don't have to keep updating pypi and conda-forge with every minor update of the package. \"\"\" import shutil try : download_dir = os . getcwd () clone_repo ( out_dir = download_dir ) pkg_dir = os . path . join ( download_dir , \"whiteboxgui-master\" ) work_dir = os . getcwd () os . chdir ( pkg_dir ) if shutil . which ( \"pip\" ) is None : cmd = \"pip3 install .\" else : cmd = \"pip install .\" os . system ( cmd ) os . chdir ( work_dir ) os . remove ( pkg_dir + \".zip\" ) shutil . rmtree ( pkg_dir ) print ( \" \\n Please comment out 'whiteboxgui.update_package()' and restart the kernel to take effect: \\n Jupyter menu -> Kernel -> Restart & Clear Output\" ) except Exception as e : raise Exception ( e )","title":"update_package()"}]}